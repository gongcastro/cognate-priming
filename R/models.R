#' Prepare time course data for modelling
#' 
#' @param gaze Data frame with the processed eye-tracking data, as generated by [get_gaze]
#' @param participants Data frame with participant-level information, as generated by [get_participants].
#' @param vocabulary Data frame with vocabulary-size information, as generated by [get_vocabulary].
#' @param attrition_trials Data frame with trial-level inclusion criteria, as generated by [get_attrition_trials].
#' @param attrition_participants Data frame with participants-level inclusion criteria, as generated by [get_attrition_participants].
#' @param time_subset Numeric vector of length 2 indicating the time window of interest to subset for time course analyses.
#' 
get_data <- function(gaze, participants, vocabulary,
					 attrition_trials, attrition_participants,
					 time_subset = c(0.00, 2.00)){
	
	if (length(time_subset)!=2 || min(time_subset) < 0 || class(time_subset)!="numeric") {
		cli_abort("time_subset must be a positive numeric vector of length 2")
	}
	
	d_g <- filter(gaze, phase=="Target-Distractor",
				  timestamp >= time_subset[1],
				  timestamp < time_subset[2]) |> 
		select(session_id, trial, phase, timestamp,
			   is_gaze_target, is_gaze_distractor, trial_type) |> 
		mutate(condition = recode_condition(trial_type),
			   timebin = findInterval(timestamp, seq(time_subset[1], 
			   									  time_subset[2], 0.1))-1) 
	
	d_v <- rename_with(vocabulary,  
					   \(x) gsub("_prop", "", paste0("voc_", x)), 
					   matches("_prop"))
	
	d_p <- select(participants, child_id, session_id, age_group, age, lp)
	
	d_at <- filter(attrition_trials, is_valid_trial) |> 
		select(session_id, trial, samples, is_valid_trial) 
	
	d_ap <- filter(attrition_participants, is_valid_participant) |> 
		select(session_id)
	
	out <- d_g |>
		inner_join(d_at, by = join_by(session_id, trial)) |> 
		inner_join(d_ap, by = join_by(session_id)) |> 
		mutate(condition = recode_condition(trial_type)) |> 
		select(session_id, trial, timebin, timestamp,
			   condition, is_gaze_target, is_gaze_distractor) |> 
		# aggregate across trials by participant, time bin and condition
		# see Chow et al. (2018)
		summarise(.sum_t = sum(is_gaze_target, na.rm = TRUE),
				  .sum_d = sum(is_gaze_distractor, na.rm = TRUE),
				  .ntrials = length(unique(trial)),
				  .by = c(session_id, timebin, condition)) |> 
		# empirical logit with adjustment
		# see Barr et al. (2008)
		mutate(.nsamples = .sum_t + .sum_d,
			   .prop = if_else(.nsamples==0, NA_real_, .sum_t / .nsamples),
			   .elog = log((.sum_t + .5)/(.sum_d + .5))) |> 
		arrange(desc(session_id), condition, timebin) |> 
		inner_join(d_p, by = join_by(session_id)) |> 
		inner_join(d_v, by = join_by(child_id, session_id)) |> 
		mutate(across(c(.nsamples, timebin), as.integer),
			   across(c(child_id, session_id, lp, condition, age_group), as.factor),
			   across(c(age, matches("voc_"), timebin),
			   	   \(x) scale(x, scale = TRUE)[, 1],
			   	   .names = "{.col}_std")) |> 
		select(child_id, session_id, age_group, age, voc_l1, voc_total, lp,
			   condition, timebin, .sum_t, .sum_d, .prop, .elog, .nsamples,
			   matches("_std")) 
	
	contrasts(out$condition) <- cbind(c(-0.5, 0.5, 0),
									  c(0, -0.5, 0.5))
	contrasts(out$lp) <- cbind(c(-0.5, 0.25, 0.25),
							   c(0, -0.5, 0.5))
	contrasts(out$age_group) <- cbind(c(-0.5, 0.25, 0.25),
									  c(0, -0.5, 0.5))
	
	# test_data_time(data_time)
	
	return(out)
	
}

#' Recode condition levels
#' 
recode_condition <- function(x) {
	fct_levels <- list("Unrelated" = "Unrelated",
					   "Non-cognate" = "Related/Non-cognate",
					   "Cognate" = "Related/Cognate")
	x <- factor(x, levels = names(fct_levels), labels = fct_levels)
	return(x)
}

#' Fit multiple models given a list of formulas
#' 
#' @param names Character vector of same length as `formulas` with the name of each model
#' @inheritParams brms::brm
get_model_fit <- function(names, formulas, data, prior, ...) {
	
	if (!is.list(formulas)) {
		cli_abort("formula must be a named list")
	}
	if (!is.data.frame(data)) {
		cli_abort('data must be a data frame')
	}
	
	fit_lst <- map2(.x = names,
					.y = formulas,
					.f = \(names, formulas) {
						fit_single_model(names, formulas, data, prior, ...)
					},
					.progress = TRUE) |> 
		set_names(gsub("cognate_|related_", "", names))
	
	return(fit_lst)
}

#' Estimate model using Hamiltonian Monte Carlo via Stan
#' @param names Name of each model
#' @inheritParams brms::brm
#' 
fit_single_model <- function(name, formula, data, prior, ...) {
	
	model_path <- file.path("results", "fits", paste0(name, ".rds"))
	
	model_opts <- list(adapt_delta = 0.9, max_treedepth = 15)
	
	fit <- brm(formula = formula,
			   data = data,
			   prior = prior,
			   iter = 500,
			   chains = 6,
			   cores = 6,
			   init = 0.1,
			   file_refit = "on_change",
			   file = model_path,
			   seed = 1234,
			   control = model_opts,
			   silent = 2,
			   ...)
	
	return(fit)
}	

#' Leave-one-out cross-validation (LOO-CV)
get_model_loos <- function(models, ...) {
	
	loos <- brms::loo_compare(purrr::map(.x = models, 
										 .f = \(x) brms::loo(x, ...), 
										 .progress = TRUE))
	
	return(loos)
}